# DFM核心算法一致性验证 - 设计文档

## 架构设计

### 整体测试架构

```
tests/consistency/
├── data_generator.py           # 模拟数据生成器
├── base.py                      # 对比测试基类(扩展)
├── fixtures/                    # 标准测试数据集
│   ├── small_dataset.npz
│   ├── medium_dataset.npz
│   ├── large_dataset.npz
│   └── single_factor_dataset.npz
├── test_pca_consistency.py      # PCA一致性测试
├── test_kalman_filter_consistency.py   # 卡尔曼滤波测试
├── test_kalman_smoother_consistency.py # 卡尔曼平滑测试
├── test_em_estimation_consistency.py   # EM参数估计测试
├── test_full_pipeline_consistency.py   # 全流程集成测试
└── report_generator.py          # 验证报告生成器
```

### 测试层次结构

```
┌─────────────────────────────────────────┐
│  Phase 6: 真实数据验证测试              │
│  (使用经济数据库1017.xlsx)             │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│  Phase 5: 全流程集成测试                │
│  (模拟数据 + 完整训练流程)              │
└──────────────┬──────────────────────────┘
               │
      ┌────────┴────────┐
      │                 │
┌─────▼──────┐  ┌───────▼──────┐
│ Phase 2-4: │  │ Phase 3-4:  │
│ PCA单元   │  │ 卡尔曼+EM   │
│ 测试      │  │ 单元测试    │
└────────────┘  └──────────────┘
      │                 │
      └────────┬────────┘
               │
┌──────────────▼──────────────────────────┐
│  Phase 1: 测试基础设施                  │
│  (数据生成器 + 对比工具)                │
└─────────────────────────────────────────┘
```

## 模拟数据生成器设计

### 数据生成原理

**真实DFM过程**:

1. **因子过程** (AR(1)或VAR(1)):
   ```
   F_t = A * F_{t-1} + eta_t,  eta_t ~ N(0, Q)
   ```

2. **观测方程**:
   ```
   Z_t = Lambda * F_t + eps_t,  eps_t ~ N(0, R)
   ```

**参数配置**:
- Lambda: 因子载荷矩阵 (n_obs × k_factors)
  - 稀疏结构(每个变量主要受1-2个因子影响)
  - 载荷值范围: [-2, 2]
- A: 状态转移矩阵 (k_factors × k_factors)
  - 对角占优(AR结构)
  - 特征值 < 1(平稳性)
- Q: 过程噪声协方差 (k_factors × k_factors)
  - 对角矩阵,方差 ~ 0.1
- R: 观测噪声协方差 (n_obs × n_obs)
  - 对角矩阵,方差 ~ 0.5

### 数据集配置表

| 数据集 | 时间点(T) | 变量数(N) | 因子数(k) | 缺失率 | 用途 |
|--------|----------|----------|----------|--------|------|
| small | 50 | 10 | 2 | 0% | 快速单元测试 |
| medium | 200 | 30 | 3 | 0% | 标准集成测试 |
| large | 500 | 50 | 5 | 0% | 性能和稳定性测试 |
| single_factor | 100 | 20 | 1 | 0% | 边界情况测试 |
| high_dim | 300 | 100 | 10 | 0% | 高维模型测试 |
| missing_5pct | 200 | 30 | 3 | 5% | 缺失数据测试 |
| missing_20pct | 200 | 30 | 3 | 20% | 稀疏数据测试 |

### 关键设计决策

**为什么使用模拟数据而非真实数据?**

1. **可控性**: 模拟数据的真实参数已知,可以验证估计精度
2. **可重现性**: 固定随机种子,确保每次运行结果一致
3. **覆盖性**: 可以生成边界情况(极小样本、高维、缺失等)
4. **隔离性**: 排除数据质量问题,专注算法本身

**为什么同时需要真实数据测试?**

1. **现实性**: 验证算法在真实数据分布下的表现
2. **完整性**: 测试完整的数据预处理→训练→评估流程
3. **业务验证**: 确保重构版在生产场景下行为一致

## 对比测试工具设计

### 数值对比函数

```python
def compare_arrays(
    arr1: np.ndarray,
    arr2: np.ndarray,
    rtol: float = 1e-10,
    atol: float = 1e-10,
    name: str = "array"
) -> Dict[str, Any]:
    """数组逐元素对比

    Returns:
        {
            'max_abs_diff': float,      # 最大绝对差异
            'mean_abs_diff': float,     # 平均绝对差异
            'max_rel_diff': float,      # 最大相对差异
            'is_close': bool,           # 是否在容差内
            'diff_indices': List[Tuple] # 超出容差的索引
        }
    """
```

```python
def compare_matrices(
    mat1: np.ndarray,
    mat2: np.ndarray,
    norm: str = 'fro',
    rtol: float = 1e-10
) -> Dict[str, Any]:
    """矩阵对比(支持Frobenius范数)

    Returns:
        {
            'frobenius_diff': float,    # Frobenius范数差异
            'max_eigenvalue_diff': float, # 最大特征值差异
            'is_close': bool
        }
    """
```

```python
def compare_state_space_params(
    params1: Dict[str, np.ndarray],
    params2: Dict[str, np.ndarray],
    rtol: float = 1e-10
) -> Dict[str, Dict[str, Any]]:
    """状态空间参数对比

    对比: Lambda, A, Q, R
    返回每个参数的详细对比结果
    """
```

### 断言工具

```python
def assert_numerical_consistency(
    actual: np.ndarray,
    expected: np.ndarray,
    rtol: float = 1e-10,
    atol: float = 1e-10,
    context: str = ""
):
    """统一的数值一致性断言

    失败时提供详细的诊断信息:
    - 最大差异位置
    - 差异分布直方图
    - 建议的调试步骤
    """
```

## 核心算法对比策略

### PCA算法对比

**对比点**:
1. 协方差矩阵计算: `S = (1/T) * Z'Z`
2. 特征值分解: `eigenvalues, eigenvectors`
3. 因子载荷初始化: `Lambda = sqrt(T) * eigenvectors * sqrt(eigenvalues)`
4. 因子提取: `F = Z * eigenvectors`

**注意事项**:
- 特征向量符号不确定性: 使用 `abs(v1 - v2)` 或 `abs(v1 + v2)` 取最小值
- 数值库差异: train_model使用numpy.linalg.eigh, train_ref也使用相同函数

### 卡尔曼滤波对比

**对比点**:
1. **预测步骤**:
   - `x_pred[t] = A * x_filt[t-1]`
   - `P_pred[t] = A * P_filt[t-1] * A' + Q`

2. **更新步骤**:
   - `K[t] = P_pred[t] * H' * inv(S[t])`  (卡尔曼增益)
   - `x_filt[t] = x_pred[t] + K[t] * innovation[t]`
   - `P_filt[t] = (I - K[t]*H) * P_pred[t]`

**数值稳定性**:
- 协方差矩阵对称性: `P = (P + P') / 2`
- 正定性检查: 特征值 > min_eigenvalue_threshold

### 卡尔曼平滑对比

**对比点**:
1. **RTS平滑增益**:
   ```
   C[t] = P_filt[t] * A' * inv(P_pred[t+1])
   ```

2. **平滑状态**:
   ```
   x_sm[t] = x_filt[t] + C[t] * (x_sm[t+1] - x_pred[t+1])
   P_sm[t] = P_filt[t] + C[t] * (P_sm[t+1] - P_pred[t+1]) * C[t]'
   ```

3. **滞后协方差**:
   ```
   P_lag_sm[t] = P_sm[t+1] * C[t]'
   ```

**边界条件**:
- 初始化: `x_sm[T] = x_filt[T], P_sm[T] = P_filt[T]`
- 反向递归: 从 T-1 到 0

### EM参数估计对比

**E步对比** (已在卡尔曼滤波/平滑中验证):
- 运行卡尔曼滤波器获取滤波估计
- 运行卡尔曼平滑器获取平滑估计

**M步对比**:
1. **载荷矩阵更新**:
   ```python
   Lambda = (Z * F') * inv(F * F')  # OLS回归
   ```

2. **转移矩阵更新**:
   ```python
   sum1 = sum_t P_lag_sm[t] + x_sm[t] * x_sm[t-1]'
   sum2 = sum_t P_sm[t-1] + x_sm[t-1] * x_sm[t-1]'
   A = sum1 * inv(sum2)
   ```

3. **协方差矩阵更新**:
   ```python
   Q = (1/T) * sum_t [P_sm[t] - A*P_lag_sm[t]' +
                      (x_sm[t] - A*x_sm[t-1]) * (x_sm[t] - A*x_sm[t-1])']

   R = (1/T) * sum_t [(z[t] - Lambda*x_sm[t]) * (z[t] - Lambda*x_sm[t])' +
                      Lambda * P_sm[t] * Lambda']
   ```

**收敛检查**:
- 对数似然变化: `|loglik[i] - loglik[i-1]| < tolerance`

## 集成测试设计

### 测试场景矩阵

| 场景ID | 因子数(k) | 数据规模(T×N) | 缺失率 | 初始化方法 | 期望结果 |
|--------|----------|--------------|--------|----------|---------|
| S1 | 1 | 50×10 | 0% | PCA | 参数差异 < 1e-8 |
| S2 | 2 | 200×30 | 0% | PCA | 参数差异 < 1e-8 |
| S3 | 3 | 200×30 | 0% | PCA | 参数差异 < 1e-8 |
| S4 | 5 | 500×50 | 0% | PCA | 参数差异 < 1e-8 |
| S5 | 10 | 300×100 | 0% | PCA | 参数差异 < 1e-8 |
| S6 | 3 | 200×30 | 5% | PCA | 参数差异 < 1e-8 |
| S7 | 3 | 200×30 | 20% | PCA | 参数差异 < 1e-8 |
| S8 | 2 | 200×30 | 0% | Random | 参数差异 < 1e-6(可能更大) |
| S9 | 3 | 200×30 | 0% | User-specified | 参数差异 < 1e-8 |
| S10 | 2 | 实际数据 | 真实缺失 | PCA | RMSE差异 < 1e-4 |

### 测试执行流程

```
1. 加载标准测试数据集(或生成模拟数据)
   ↓
2. 设置相同的随机种子(SEED=42)
   ↓
3. 运行train_model训练流程
   - 记录所有中间结果
   - 保存最终模型参数
   ↓
4. 重置随机种子(SEED=42)
   ↓
5. 运行train_ref训练流程
   - 记录所有中间结果
   - 保存最终模型参数
   ↓
6. 对比中间结果和最终结果
   - PCA初始化
   - 每次EM迭代的参数
   - 最终收敛参数
   - 样本内外预测
   - 评估指标
   ↓
7. 生成对比报告
   - 数值差异统计
   - 可视化对比图
   - 结论和建议
```

## 报告生成器设计

### 报告内容结构

```markdown
# DFM核心算法一致性验证报告

## 1. 执行摘要
- 测试日期
- 测试版本(train_model vs train_ref)
- 总体通过率
- 关键发现

## 2. 测试覆盖率
- 单元测试统计(Phase 2-4)
- 集成测试统计(Phase 5-6)
- 代码覆盖率

## 3. 数值一致性结果
### 3.1 PCA算法
- 协方差矩阵差异: max/mean/std
- 特征值差异
- 特征向量子空间距离
- 通过/失败案例

### 3.2 卡尔曼滤波
- 预测状态差异
- 滤波状态差异
- 卡尔曼增益差异
- 通过/失败案例

### 3.3 卡尔曼平滑
- 平滑状态差异
- 平滑协方差差异
- 滞后协方差差异
- 通过/失败案例

### 3.4 EM参数估计
- 载荷矩阵差异
- 转移矩阵差异
- 协方差矩阵差异
- 收敛速度对比
- 通过/失败案例

### 3.5 全流程集成
- 不同配置下的结果对比
- 预测指标对比(RMSE, Hit Rate)
- 真实数据测试结果
- 通过/失败案例

## 4. 可视化对比
- 数值差异分布直方图
- 时间序列对比图(滤波/平滑状态)
- 矩阵差异热力图(Lambda, A, Q, R)
- EM收敛曲线对比

## 5. 问题分析
- 发现的数值不一致问题列表
- 根因分析
- 修复建议

## 6. 结论和建议
- 一致性验证结论
- 残余风险评估
- 后续行动建议
```

### 报告格式

- **HTML报告**: 交互式,包含可折叠的详细对比表格和图表
- **PDF报告**: 打印版,适合存档和分享
- **JSON数据**: 结构化数据,便于自动化分析

## 性能考虑

### 测试执行时间估算

| Phase | 测试数量 | 单个耗时 | 总耗时 |
|-------|---------|---------|--------|
| Phase 2 (PCA) | 5 | ~5秒 | ~25秒 |
| Phase 3 (卡尔曼) | 10 | ~10秒 | ~100秒 |
| Phase 4 (EM) | 8 | ~30秒 | ~240秒 |
| Phase 5 (集成) | 10 | ~2分钟 | ~20分钟 |
| Phase 6 (真实数据) | 4 | ~5分钟 | ~20分钟 |
| **总计** | **37** | - | **~45分钟** |

### 优化策略

1. **并行测试执行**: 使用pytest-xdist并行运行独立测试
2. **缓存中间结果**: baseline结果只生成一次,后续测试复用
3. **增量测试**: 代码修改后只运行相关测试
4. **CI/CD集成**: 每次提交自动运行快速测试套件,定期运行完整测试

## 风险缓解

### 已知风险和应对策略

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| 数值库版本差异 | 中 | 低 | 固定numpy/scipy版本,文档化依赖 |
| 浮点运算顺序差异 | 中 | 中 | 放宽集成测试容差到1e-6 |
| 随机种子失效 | 高 | 低 | 多个seed测试,验证可重现性 |
| 特征向量符号差异 | 低 | 高 | 对比子空间距离而非逐元素 |
| 测试数据覆盖不全 | 中 | 中 | 结合模拟+真实数据,多场景测试 |

## 未来扩展

1. **持续监控**: 建立算法性能监控dashboard,跟踪数值稳定性趋势
2. **基准数据库**: 建立标准测试数据集库,支持回归测试
3. **差异诊断工具**: 开发交互式工具,快速定位数值差异根因
4. **性能基准测试**: 扩展到执行时间和内存占用对比
